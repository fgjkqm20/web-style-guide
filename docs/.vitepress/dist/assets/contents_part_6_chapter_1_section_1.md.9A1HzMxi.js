import{_ as t,c as s,o as i,R as a}from"./chunks/framework.kkHJ_Qlh.js";const e="/web-style-guide/assets/1.t5add3_A.png",E=JSON.parse('{"title":"Section 1 페이지 구조 마크업","description":"","frontmatter":{},"headers":[],"relativePath":"contents/part/6/chapter/1/section/1.md","filePath":"contents/part/6/chapter/1/section/1.md"}'),o={name:"contents/part/6/chapter/1/section/1.md"},l=a('<h1 id="section-1-페이지-구조-마크업" tabindex="-1">Section 1 페이지 구조 마크업 <a class="header-anchor" href="#section-1-페이지-구조-마크업" aria-label="Permalink to &quot;Section 1 페이지 구조 마크업&quot;">​</a></h1><p>2000년대 중반 마크업 언어가 어떤 방향으로 향했는지 잠시 되돌아보자. 그 당시 최첨단 기술은 페이지 레이아웃, 타이포그래피 및 기본 페이지 그래픽을 위한 CSS와 결합된 신중하게 검증된 의미론적 XHTML 마크업을 완전히 수용하는 것이었습니다. 페이지 레이아웃에 CSS 기능을 사용하기 위해 디자이너는 CSS 마크업을 걸기 위해 수십 개의 일반 분할 <code>&lt;div&gt;</code>(및 <code>&lt;span&gt;</code>) 컨테이너로 HTML 코드를 채웠고 결과적으로 <code>&lt;div&gt;</code>가 폭발적으로 증가했습니다. 컨테이너는 때때로 기본 페이지 레이아웃조차 터무니없이 복잡하게 만들었습니다</p><figure><img id="figure1" alt="" src="'+e+`"><figcaption> 그림 1 </figcaption></figure><p>이러한 새로운 페이지 디자인 방식이 널리 보급됨에 따라 많은 디자이너들은 새로운 코딩 방식의 복잡성과 중복성, 그리고 암시적인 아이러니를 인지했습니다. 즉, CSS를 사용한 페이지 디자인은 페이지 마크업을 단순화하는 데 도움이 되어야 한다는 것이었습니다. 그러나 CSS의 새로운 기능으로 인해 디자이너는 그래픽을 훨씬 더 복잡하게 만들게 되었고 마크업 코드도 그 어느 때보다 복잡해졌습니다. 2005년에 Google은 10억 개가 넘는 게시된 웹 페이지의 페이지 코드를 분석하는 연구를 수행했습니다. 특히 디자이너가 HTML 클래스, <code>&lt;div&gt;</code> 및 ID 이름을 사용하는 방법을 조사하고 페이지 코드에서 일반적인 의미 패턴을 발견했습니다. 지배적인 명명 패턴은 꽤 논리적이었으며 &quot;머리글&quot;, &quot;바닥글&quot;, &quot;탐색&quot;, &quot;콘텐츠&quot; 또는 &quot;주 콘텐츠&quot;와 같은 공통 페이지 영역을 중심으로 이루어졌습니다.</p><p><code>&lt;div&gt;</code> 컨테이너 코딩의 폭발적인 증가는 CSS를 사용한 스타일링에만 관련된 것이 아닙니다. 또한 HTML이 마크업 언어로 성숙하려면 공통된 내용을 설명하기 위해 보다 풍부한 의미 체계 세트를 통합해야 한다는 것도 분명했습니다. 섹션, 기사, 옆 부분 또는 인용문과 같은 콘텐츠 컨테이너입니다. 디자이너들은 2000년대 초 HTML 4.0 및 2000년대 초 HTML 4.0의 마크업 제한을 보완하기 위해 콘텐츠 블록의 시각적 스타일을 지정하고 특정 콘텐츠 블록을 RSS와 같은 콘텐츠 신디케이션 체계에 더 쉽게 적용할 수 있도록 일반 <code>&lt;div&gt;</code> 컨테이너를 점점 더 많이 사용하고 있습니다. XHTML. 따라서 디자이너가 XHTML의 의미론적 한계로 인해 어려움을 겪을 때 <code>&lt;div class=&quot;article&quot;&gt;</code>, <code>&lt;div class=&quot;section&quot;&gt;</code>, <code>&lt;div class=&quot;pullquote&quot;&gt;</code>와 같은 마크업을 보는 것이 일반적이었습니다.</p><p>2000년대 후반에 점진적으로 등장한 새로운 HTML5는 보다 논리적인 페이지 구조 태그, 콘텐츠에 대한 보다 풍부한 의미 체계 마크업 세트, 웹 기반 애플리케이션 개발을 위한 도구에 대한 실제 웹 디자인의 요구 사항을 해결하기 위해 특별히 설계되었습니다. HTML5의 새로운 마크업 태그 중 다수는 현대 웹 관행의 &quot;길을 닦기&quot; 위해 특별히 설계되었으며 실제 코딩 방법의 비공식적이지만 논리적인 즉흥성을 HTML5의 공식 사양에 도입했습니다. HTML5에는 이제 페이지 구조를 설명하고 보다 풍부한 콘텐츠 의미 태그 세트를 제공하는 새로운 의미 태그 세트가 있습니다.</p><h2 id="_1-페이지-구조-의미" tabindex="-1">1. 페이지 구조 의미 <a class="header-anchor" href="#_1-페이지-구조-의미" aria-label="Permalink to &quot;1. 페이지 구조 의미&quot;">​</a></h2><p>페이지 구조 의미론은 머리글, 바닥글, 탐색 영역과 같은 일반적인 유형의 페이지 영역을 지정합니다. 이러한 공통 페이지 요소를 포함하기 위해 많은 고유 <code>&lt;div&gt;</code> ID를 생성할 필요 없이 코더는 새 요소를 사용하고 직접 스타일을 지정할 수 있습니다. 페이지 영역 레이아웃의 오랜 관행을 정규화하면 시각 장애인을 위한 검색 엔진 및 브라우저와 같은 자동화된 시스템이 페이지의 과거 구조 요소를 찾고 강조 표시하거나 건너뛰는 것이 훨씬 쉬워졌습니다.</p><p><code>&lt;head&gt;</code> 및 <code>&lt;body&gt;</code>와 같은 오랜 HTML 페이지 구조 태그 외에도 HTML5에는 이제 페이지 요소 설명을 풍부하게 하는 다음과 같은 새로운 태그가 있습니다.</p><ul><li><strong>헤더:</strong> 페이지의 헤더 영역이나 섹션 또는 기사의 헤더를 정의합니다. 페이지 헤더에는 탐색 요소(<code>&lt;nav&gt;</code>)가 포함되는 경우가 많습니다. 기사, 섹션 및 기타 항목은 모두 자체 헤더 영역을 포함할 수 있습니다.</li><li><strong>탐색:</strong> 주요 탐색 요소를 포함하도록 설계된 요소입니다. 이는 주요 사이트 섹션에 대한 전역 탐색 링크이거나 로컬 하위 섹션 주제에 대한 탐색인 경우가 많습니다.</li><li><strong>기본:</strong> 페이지의 모든 주요 콘텐츠 요소를 포함하도록 설계되었습니다. 이 태그는 화면 판독기 웹 브라우저의 접근성에 유용합니다. 판독기가 페이지 콘텐츠로 바로 이동할 수 있도록 하기 때문입니다. 검색 엔진이 페이지의 중앙 콘텐츠에 플래그를 지정할 수 있도록 하는 데에도 유용합니다.</li><li><strong>Aside:</strong> <code>&lt;aside&gt;</code> 요소에는 두 가지 주요 용도가 있습니다. 탐색에 사용되는 사이드바와 같은 페이지 레이아웃 컨테이너로 사용하거나 기본 페이지 콘텐츠에서 &quot;별도로&quot; 다른 콘텐츠를 사용하는 것입니다. <code>&lt;aside&gt;</code> 요소는 &#39;사이드바&#39; 기사나 설명 메모에서와 같이 페이지의 주요 콘텐츠 설명을 제외하고 괄호로 묶인 관련 콘텐츠를 지정하는 데에도 사용할 수 있습니다.</li><li><strong>바닥글:</strong> <code>&lt;footer&gt;</code> 요소는 일반적으로 페이지의 끝을 표시하며 일반적으로 웹사이트에 대한 일반 정보, 저작권 또는 기타 날짜 정보, 연락처 정보를 포함합니다. <code>&lt;footer&gt;</code> 요소는 섹션이나 기사의 끝 부분에 사용되어 각주, 참고문헌 또는 일반적으로 섹션이나 기사의 끝 부분에 나열된 기타 자료를 보관할 수 있습니다.</li></ul><h2 id="_2-html5의-새로운-콘텐츠-의미-요소" tabindex="-1">2. HTML5의 새로운 콘텐츠 의미 요소 <a class="header-anchor" href="#_2-html5의-새로운-콘텐츠-의미-요소" aria-label="Permalink to &quot;2. HTML5의 새로운 콘텐츠 의미 요소&quot;">​</a></h2><p>이것은 HTML5의 새로운 콘텐츠 의미 요소의 일부 목록입니다. 새로운 요소는 검색 엔진 및 기타 자동화된 페이지 검색 시스템이 더 지능적으로 페이지를 &quot;읽을&quot; 수 있도록 콘텐츠 섹션과 구성 요소에 레이블을 지정하는 훨씬 더 자세한 방법을 제공합니다. 또한 더 자세한 콘텐츠 마크업을 사용하면 섹션 및 기사와 같이 정의된 콘텐츠 블록을 더 쉽게 재사용할 수 있습니다.</p><ul><li><strong>기사:</strong> 독립적이거나 독립적인 콘텐츠 덩어리입니다. 다른 페이지나 사이트에서 재사용할 수 있고 원래 컨텍스트 밖에서도 독립적이고 이해할 수 있는 콘텐츠 블록을 지정하는 수단으로 설계되었습니다. <code>&lt;section&gt;</code>이나 <code>&lt;article&gt;</code> 요소는 페이지의 콘텐츠를 시각적으로 스타일 지정하거나 배치하는 데에만 사용되어서는 안 됩니다. 페이지 영역에 CSS 스타일을 적용하기 위한 컨테이너만 필요한 경우 <code>&lt;div&gt;</code> 요소를 사용하세요.</li><li><strong>별도:</strong> 본 내용과 괄호 안에 관련되어 있지만, 본 내용의 서사에서 제외된 내용입니다. 인쇄 출판물에서는 옆면이 &quot;사이드바&quot; 기사로 구분되는 경우가 많습니다. <code>&lt;aside&gt;</code> 요소는 페이지 레이아웃의 사이드바 열을 지정하는 데 사용될 수도 있습니다.</li><li><strong>세부정보:</strong> JavaScript로 구동되는 팝업 설명 노트와 같이 공개하거나 숨길 수 있는 설명 내용을 지정하기 위한 새로운 요소입니다. 세부정보를 공개하려면 클릭하세요. 메모를 숨기려면 다시 클릭하세요. 관련 <code>&lt;summary&gt;</code> 요소를 참조하세요.</li><li><strong>그림:</strong> 일러스트레이션, 사진, 다이어그램 등과 같이 밀접하게 관련된 그래픽의 개별 그림 또는 그룹을 위한 컨테이너입니다.</li><li><strong>Figcaption:</strong> 그림의 캡션을 지정합니다. <code>&lt;figcaption&gt;</code> 요소는 관련 <code>&lt;Figure&gt;</code> 요소 내에 중첩되어야 합니다.</li><li><strong>표시:</strong> 표시되거나 강조 표시된 텍스트 또는 다른 의미 목적으로 구별되는 텍스트를 정의합니다.</li><li><strong>섹션:</strong> 문서의 섹션을 정의합니다. 이는 의도적으로 광범위한 정의를 내린 것으로, 결정은 주로 저자의 몫입니다. 섹션은 한두 단락일 수도 있고 전체 장일 수도 있습니다.</li><li><strong>요약:</strong> 팝업 <code>&lt;details&gt;</code> 요소와 연결된 표시되는 텍스트입니다. <code>&lt;summary&gt;</code> 및 <code>&lt;details&gt;</code> 요소는 일반적으로 JavaScript로 제어되는 팝업 설명 메모에 사용됩니다. 사용자가 요약을 클릭하면 <code>&lt;details&gt;</code> 요소가 설명 텍스트와 함께 나타나고, 사용자가 다시 클릭하면 세부정보 텍스트가 사라집니다.</li><li><strong>시간:</strong> 날짜(일반적으로 yyyy-mm-dd 형식) 또는 시간(24시간제)을 정의합니다.</li></ul><div class="language-HTML vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">HTML</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!--예시--&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  연극 상영 시간은 &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;20:00&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;입니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  연극 첫 상영은 &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;2016-05-15, 20:00&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;에 합니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ul><li><strong>캔버스:</strong> <code>&lt;canvas&gt;</code> 요소를 사용하면 웹페이지의 직사각형 영역을 지정할 수 있습니다. 여기서 JavaScript 또는 기타 논리 프로그래밍을 통한 스크립트 제어 하에 미래의 가능성을 포함하여 대화형 그래픽과 애니메이션을 만들 수 있습니다. 대화형 3D 객체. 지금까지 <code>&lt;canvas&gt;</code> 요소는 기발한 그래픽 데모와 조잡한 애니메이션 외에는 실용적인 적용이 거의 없는 흥미로운 가능성이었습니다. Adobe Flash Professional CC의 최근 캔버스 상호 작용 지원을 통해 이번에는 Flash와 같은 독점 파일 형식이 아닌 <code>&lt;canvas&gt;</code> 요소에 내재된 가능성을 유용하게 활용하는 보다 유용한 대화형 콘텐츠를 볼 수 있습니다.</li><li><strong>비디오 및 오디오:</strong> HTML5에는 Adobe Flash와 같은 독점 브라우저 플러그인 없이 웹 페이지에 오디오 및 비디오 파일을 모두 삽입하는 표준 방법이 포함되어 있습니다. 불행하게도 HTML5 비디오는 여전히 진행 중인 작업입니다. 다양한 비디오 형식(.mov, .ogv, .m4v 등)에 대한 브라우저 지원이 부족하여 현재 각 비디오를 세 가지 다른 파일 형식으로 인코딩해야 할 수 있습니다. 주요 브라우저(Chrome, Firefox 및 Internet Explorer)에서 재생되는지 확인하고 페이지에 JavaScript를 포함하여 다른 브라우저에서 비디오가 지원되지 않는지 테스트합니다. 현재 우리의 조언은 HTML5 비디오에 대한 더 광범위하고 일관된 브라우저 지원이 있을 때까지 Vimeo 또는 YouTube의 비디오 삽입을 고수하라는 것입니다.</li><li><strong>SVG:</strong> 확장 가능한 벡터 그래픽(SVG)은 xml 텍스트 형식으로 xy 좌표와 곡선으로 설명된 기하학적 모양으로 구성됩니다. SVG는 벡터 그래픽이기 때문에 매우 컴팩트할 수 있습니다. 픽셀 격자로 구성된 Adobe Photoshop 또는 jpeg 비트맵 파일과 달리 Adobe Illustrator 파일(독점적인 벡터 그래픽 형식)을 생각하면 됩니다. SVG는 JavaScript 제어 하에서 애니메이션화되고 대화형이 될 수도 있습니다. SVG는 HTML5의 표준 구성 요소이며 주요 브라우저에서 광범위하게 지원되지만 아직은 jpeg 및 png 형식의 그래픽과 비교하여 거의 사용되지 않습니다. 웹 그래픽 형식에 대한 자세한 내용은 8장, 그래픽 디자인을 참조하세요.</li></ul><h2 id="_3-html5-및-drupal-및-wordpress와-같은-cms" tabindex="-1">3. HTML5 및 Drupal 및 WordPress와 같은 CMS <a class="header-anchor" href="#_3-html5-및-drupal-및-wordpress와-같은-cms" aria-label="Permalink to &quot;3. HTML5 및 Drupal 및 WordPress와 같은 CMS&quot;">​</a></h2><p>몇 페이지가 넘는 대부분의 사이트는 Drupal, WordPress 또는 기타 상용 CMS 소프트웨어와 같은 CMS 내에 구축되어야 하지만 이러한 복잡한 시스템은 코드 표준의 변경 사항을 적용하는 데 시간이 더 걸립니다. 그러나 CMS가 제공하는 실질적인 이점을 고려하면 최신 코드 표준을 채택하는 데 지연이 발생하는 것은 상대적으로 사소한 문제입니다. WordPress와 Drupal은 모두 HTML5 및 CSS3 요소를 핵심 릴리스에 꾸준히 통합하고 있습니다. 이 두 가지 인기 있는 CMS는 아직 완전한 HTML5 기반 시스템은 아니지만 Drupal과 WordPress의 다음 주요 릴리스는 HTML5와 CSS3를 기반으로 할 것입니다. 그 동안 WordPress에는 완벽하게 반응하는 HTML5 테마가 많이 있으며 Drupal은 HTML5 및 CSS3 요소를 Drupal 7에 가져오기 위해 반응형 테마와 모듈 기반 수단의 조합을 제공합니다. 2016년에 출시될 새로운 Drupal 8은 HTML5와 완벽하게 호환될 것을 약속합니다.</p>`,17),n=[l];function d(r,c,p,g,h,k){return i(),s("div",null,n)}const S=t(o,[["render",d]]);export{E as __pageData,S as default};
